[Intro](#information-sharing-networks) |
[Try it out](#try-it-out) |
[Developers](#developers) |
[Technical Overview](#technical-overview) 

![ci](https://github.com/information-sharing-networks/signalsd/actions/workflows/ci.yml/badge.svg)
![cd](https://github.com/information-sharing-networks/signalsd/actions/workflows/cd.yml/badge.svg)

# Information Sharing Networks
ISNs are networks that enable interested parties to share information. The information is shared in the form of "signals".

## Signals

Signals are simple messages that can be exchanged between organisations to share data, indicate that an action has been taken or that something has been decided or agreed upon. Siganls are
- light-weight, with simple payloads and a straightforward version control system. 
- can be delivered as soon as a corresponding event occurs in the originating business process.
- can move in any direction in the network.

Examples of data that might be contained in a signal
- A feature of an event 
- A piece of information related to an event or an entity
- An opinion or claim based on observation of information or events
- Insight generated by the deployment of expertise over data or events
- An attestation from an organisation that a signal produced or provided by another organisation is accurate or true
  
## Reference Implementations
The [initial implementation](https://github.com/information-sharing-networks/isn-ref-impl) was a proof of concept used as part of the UK govs Border Trade Demonstrator (BTD) initiative.  The BTDs established ISNs that were used by several goverment agencies and industry groups to make process improvements at the border by sharing supply chain information. 

This repo contains the second version (work in progress) - it develops the ISN administration facilities and will scale to higher volumes of data.

There are three components
- an [API](https://information-sharing-networks.github.io/signalsd/app/docs/index.html) used to configure ISNs, register participants and deploy the data sharing infrastructure 
- an associated [framework agreement](https://github.com/information-sharing-networks/Framework) that establishes the responsibilities of the participants in an ISN
- a demonstration UI 

## Credits
Many thanks to [Ross McDonald](https://github.com/rossajmcd) who came up with the concept and created the initial reference implemenation.

# Try it out
You can run the service on your laptop without installing any additional software using Docker.
Visit [Docker's website](https://docs.docker.com/get-docker) to download and install Docker for your operating system.
Follow the installation instructions specific to your OS.

1. [download](https://github.com/information-sharing-networks/signalsd/archive/refs/heads/main.zip) the source code (signals-main.zip)
2. unzip signals-main.zip

Then from the command line 
```
cd signals-main
docker compose up 
```
You can then use the service at [http://localhost:8080](http://localhost:8080)


To stop and remove the service, run this command from the same directory:
```
docker compose down --rmi local -v
```

# Developers

## Environment
The service uses the following environment variables
```bash
# Database connection
DATABASE_URL=postgres://user:password@host:port/database?sslmode=disable

# JWT signing key (generate a secure random string)
SECRET_KEY=your-64-character-secret-key-here

# Server configuration
HOST=0.0.0.0                    # Default: 0.0.0.0
PORT=8080                       # Default: 8080
ENVIRONMENT=prod                # Default: dev (options: dev, prod, test, staging)
LOG_LEVEL=info                  # Default: debug (options: debug, info, warn, error)

# database timeouts (optional)
READ_TIMEOUT=15s                # Default: 15s
WRITE_TIMEOUT=15s               # Default: 15s  
IDLE_TIMEOUT=60s                # Default: 60s

# CORS allowed origins (optional) - defaults to allow all origins (*)
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:3001
```

## Depenencies
The http service is written in Go and has the following development dependencies 
- [goose](https://github.com/pressly/goose) **database migrations**
- [sqlc](https://github/sqlc-dev/sqlc) **type safe code for SQL queries**
- [swaggo](https://github.com/swaggo/swag) **generates OpenApi specs from go comments**

The service uses a Postgresql@17 database. 


Instructions on installing the dependencies are below or, if you prefer, you can use the docker local dev environment which has all the dependencies pre-installed (see the next section).

## Docker local development environment
First, clone the repo. There is only one required env variable for the docker env:
```
SECRET_KEY="" # add a random secret key here (used to sign the JWT tokens used in the service)
```

Follow the instructions below to run the signalsd service.  This service handles 
- user registration
- ISN configuration
- running the receivers and retrievers that marshal the exchange of signal over the ISN

The API documentation is hosted as part of the service (alternatively you can see the documenation [here](https://information-sharing-networks.github.io/signalsd/app/docs/index.html))

```sh
cd signalsd
docker compose -f docker-compose.dev.yml up -d
Docker compose logs -f

# your local repo directory is mounted inside the container
# to test your changes, restart the app container:
docker compose restart app

#... this will regenerate  the sqlc code, rebuild the swagger API documents and recompile and run the signalsd service based on your latest changes.

# to stop the service and database 
docker compose -f docker-compose.dev.yml down

# to stop and remove all docker related images and storage:
docker compose -f docker-compose.dev.yml down --rmi local -v 
```
the service starts on [http://localhost:8080](http://localhost:8080)

To query the database, either connect to the docker app container and run the preinstalled psql client
```sh
docker exec -it -u signalsd signalsd-app-dev bash
psql postgres://signalsd-dev@localhost:15432/signalsd_admin?sslmode=disable
```

...or connect with a local postgres client
```sh
DATABASE_URL=postgres://signalsd-dev:@localhost:15432/signalsd_admin?sslmode=disable
psql $DATABASE_URL
```

## Developer local installation
(Mac)

install
- go 1.24 or above
- PostgresSql@17 or above

go dev dependencies:
``` bash
go install github.com/pressly/goose/v3/cmd/goose@latest #database migrations 
go install github.com/sqlc-dev/sqlc/cmd/sqlc@latest #type safe code for SQL queries
go install github.com/swaggo/swag/cmd/swag@latest #generates OpenApi specs from go comments

```

set the following env variables
``` bash
# sample Signals service config
DATABASE_URL="postgres://username:@localhost:5432/signalsd_admin?sslmode=disable" # on mac, username is your login username
ENVIRONMENT=dev
SECRET_KEY="" # add your random secret key here
PORT=8080
LOG_LEVEL=debug
HOST=127.0.0.1
```

the secret key is used to sign the JWT access tokens used by the service.  You can create a strong key using
``` bash
openssl rand -base64 64
```

**local postgres database setup (mac)**
``` bash
# 1 install and start postgresql server
brew install postgresql@17
brew services run postgresql@17 # use "brew servcies start" to register the service to start at login

# 2 connect to postgres server
psql postgres

# 3  and create the service database:  CREATE DATABASE signalsd_admin;

# 4 configure your connection 
DATABASE_URL="postgres://user:@localhost:5432/signalsd_admin?sslmode=disable"
```

**database migrations**
the database schema is managed by [goose](https://github.com/pressly/goose)
```
# drop all database objects
goose -dir app/sql/schema postgres $DATABASE_URL  down-to 0

# update the schema to the current version - run this after pulling code from the github repo
goose -dir app/sql/schema postgres $DATABASE_URL  up
```


**build and run**
``` bash
cd app
go build ./cmd/signalsd/
./signalsd

# or
go run cmd/signalsd/main.go
```

## API docs
To generate the OpenApi docs:
```bash
swag init -g cmd/signalsd/main.go 
```
The docs are hosted as part of the signalsd service: [API docs](http://localhost:8080/docs)

## Database 
database schema alterations are made by adding files to sql/schema
001_foo.sql
002_bar.sql 
...
goose will run the changes in the order the files are sorted.

sql queries are kept in
`app/sql/queries`

run `sqlc generate` from the root of the project to regenerate the type safe go code after adding or altering any queries



# Technical overview
## Auth
![auth.0.4.0](https://github.com/user-attachments/assets/643ec71a-f037-4a7e-9497-6023d9100e69)

## ISN config
![isns.0.2.0](https://github.com/user-attachments/assets/e091a3ae-e9ed-4b44-aa7e-027ddb93e98c)

## Signals
![signal.0.2.0](https://github.com/user-attachments/assets/86a00593-3536-4126-806d-c5b2d55232de)


## CI/CD
see github actions workflows in .github/workflows

![ci_cd.0.2.0](https://github.com/user-attachments/assets/d5399e2f-0d0b-420b-9c17-0fbcea6f520c)


## cloud deployment
The service is deployed using the image created at the last push to the main branch.  It is deployed as a container on Google Cloud Run. Google handles https, firewall, loadbalancing and autoscaling. The service will scale to zero when not in use.

![deploy.0.2.0](https://github.com/user-attachments/assets/942384a7-ccd7-4abb-b2a7-a9e293e23a10)

note this is a pre-prod version and should only be used with data that you don't mind being deleted or seen by other people.

the steps to set up this environment in Google Cloud are:
> create a project called signald 

> create an artifact registry called signalsd

> create two service accounts (IAM >Service Accounts)
  - cloud-run-deploy 
  - cloud-run-runtime

> the cloud-run-deploy account will:
 - build an image each time there is a push on main 
 - push the image to the artifact registry (the image is tagged with the commit id and 'latest'). 
 - create a container based on the latest image and deploy to Cloud Run (the container will run under the cloud-run-runtime account)
   
> The service accounts need the following permissions:
  - cloud-run-deploy needs the *Artifact Regisry Writer* and *Cloud Run Admin* roles
  - the cloud-run-runtime account does not need access to any of the google apis and therefore doesn't have any roles.  You do however need to configure it to allow the cloud-run-deploy account to use it:

    IAM > Service Accounts > cloud-run-runtime account > manage details > Pricipals with access > grant access 
  
    .. and then add the cloud-run-deploy account email address - give it the *Service Account User* role.

> Download a JSON key for the cloud-run-deploy account (IAM > service accounts > cloud-run-deploy account > keys > add key > Create New )

> Set up Github secrets in your fork of the repo (repo > settings > secrets and variables > actions > new repository secret).  You will need three:
  - GCP_CREDENTIALS (upload the contents of the json key downloaded earlier)
  - DATABASE_URL (url of your postgres service - we are using Neon.tech, but you can use any provider you choose)
  - SECRET_KEY (random secret key for your app - used by the signalsd server to sign JWT tokens)

> Note that at the time of writing this service operatates within the generous free-tiers offerred by google and Neon.Tech, but you should check the current rules to be sure.

that's it!
