[Intro](#information-sharing-networks) |
[Try It Out](#try-it-out) |
[Developer Guide](#developer-guide) |
[Technical Overview](#technical-overview)

![ci](https://github.com/information-sharing-networks/signalsd/actions/workflows/ci.yml/badge.svg)
![cd](https://github.com/information-sharing-networks/signalsd/actions/workflows/cd.yml/badge.svg)

# Information Sharing Networks
Information Sharing Networks (ISNs) are networks that enable interested parties to share information. The information is shared in the form of "signals".

## Signals

Signals are simple messages that can be exchanged between organisations to share data, indicate that an action has been taken or that something has been decided or agreed upon. Signals are:
- light-weight, with simple payloads and a straightforward version control system.
- can be delivered as soon as a corresponding event occurs in the originating business process.
- can move in any direction in the network.

Examples of data that might be contained in a signal:
- A feature of an event
- A piece of information related to an event or an entity
- An opinion or claim based on observation of information or events
- Insight generated by the deployment of expertise over data or events
- An attestation from an organisation that a signal produced or provided by another organisation is accurate or true

## Reference Implementations
The [initial implementation](https://github.com/information-sharing-networks/isn-ref-impl) was a proof of concept used as part of the UK government's Border Trade Demonstrator (BTD) initiative. The BTDs established ISNs that were used by several government agencies and industry groups to make process improvements at the border by sharing supply chain information.

This repo contains the second version (work in progress) - it develops the ISN administration facilities and will scale to higher volumes of data.

There are three components:
- an [API](https://information-sharing-networks.github.io/signalsd/app/docs/index.html) used to configure ISNs, register participants and deploy the data sharing infrastructure
- an associated [framework agreement](https://github.com/information-sharing-networks/Framework) that establishes the responsibilities of the participants in an ISN
- a demonstration UI

## Credits
Many thanks to [Ross McDonald](https://github.com/rossajmcd) who came up with the concept and created the initial reference implementation.

# Try It Out
You can run the service locally using Docker (no additional software installation required).

**Prerequisites**: [Docker Desktop](https://docs.docker.com/get-docker) installed on your system.

1. Download the [latest release](https://github.com/information-sharing-networks/signalsd/archive/refs/heads/main.zip)
2. Extract the archive: `unzip signalsd-main.zip`
3. Start the service:
   ```bash
   cd signalsd-main
   docker compose up
   ```
4. Access the service at [http://localhost:8080](http://localhost:8080)

**To stop and clean up**:
```bash
docker compose down --rmi local -v
```

# Developer Guide

## Environment Variables
The service uses the following environment variables:
```bash
# Required
DATABASE_URL=postgres://user:password@host:port/database?sslmode=disable
SECRET_KEY=your-64-character-secret-key-here  # Generate with: openssl rand -base64 64

# Server Configuration
HOST=0.0.0.0                    # Bind address (default: 0.0.0.0)
PORT=8080                       # Server port (default: 8080)
ENVIRONMENT=dev                 # Options: dev, prod, test, perf, staging (default: dev)
LOG_LEVEL=debug                 # Options: debug, info, warn, error (default: debug)

# Performance Tuning
READ_TIMEOUT=15s                # HTTP read timeout (default: 15s)
WRITE_TIMEOUT=15s               # HTTP write timeout (default: 15s)
IDLE_TIMEOUT=60s                # HTTP idle timeout (default: 60s)
RATE_LIMIT_RPS=100              # Requests per second (default: 100, set to 0 to disable)
RATE_LIMIT_BURST=20             # Burst allowance (default: 20)
MAX_SIGNAL_PAYLOAD_SIZE=5242880 # Max payload size (default: 5MB) - Note: all the other API endpoints have a 64KB limit

# Security
ALLOWED_ORIGINS=https://example.com # CORS origins (default: *, comma-separated for multiple)
```

## Dependencies
The HTTP service is written in Go and has the following development dependencies:
- [goose](https://github.com/pressly/goose) **database migrations**
- [sqlc](https://github.com/sqlc-dev/sqlc) **type safe code for SQL queries**
- [swaggo](https://github.com/swaggo/swag) **generates OpenAPI specs from go comments**

The service uses a PostgreSQL@17 database.

Instructions on installing the dependencies are below or, if you prefer, you can use the docker local dev environment which has all the dependencies pre-installed (see the next section).

## Quick Start (Docker Development Environment)
First, clone the repo:
```bash
git clone https://github.com/information-sharing-networks/signalsd.git
cd signalsd
```

The environment is set automatically in the docker container. However, if you want to customise the default values for the environment variables, you can set them before starting the docker environment, e.g
```bash
export SECRET_KEY="$(openssl rand -base64 64)"  # Generate a secure key
```

Start the development environment:
```bash
docker compose -f docker-compose.dev.yml up -d
docker compose logs -f
```

The service handles:
- User registration
- ISN configuration
- Signals exchange

The service starts on [http://localhost:8080](http://localhost:8080)

The API documentation is hosted as part of the service (alternatively you can see the documentation [here](https://information-sharing-networks.github.io/signalsd/app/docs/index.html))

### Development Workflow
```bash
# Your local repo directory is mounted inside the container
# To test your changes, restart the app container:
docker compose restart app

# This will regenerate the sqlc code, rebuild the swagger API documents
# and recompile and run the signalsd service based on your latest changes.

# To stop the service and database:
docker compose -f docker-compose.dev.yml down

# To stop and remove all docker related images and storage:
docker compose -f docker-compose.dev.yml down --rmi local -v
```

### Database Access
Connect to the database using either method:

**Via Docker container**:
```bash
docker exec -it signalsd-db-dev psql -U signalsd-dev -d signalsd_admin
```

**Via local PostgreSQL client**:
```bash
psql postgres://signalsd-dev:@localhost:15432/signalsd_admin
```

## Local Development Setup
### Prerequisites (macOS)
Install the following:
- Go 1.24 or above
- PostgreSQL@17 or above

### Go Development Dependencies
```bash
go install github.com/pressly/goose/v3/cmd/goose@latest    # database migrations
go install github.com/sqlc-dev/sqlc/cmd/sqlc@latest       # type safe code for SQL queries
go install github.com/swaggo/swag/cmd/swag@latest         # generates OpenAPI specs from go comments
```

### Environment Variables
```bash
# Sample Signals service config
DATABASE_URL="postgres://username:@localhost:5432/signalsd_admin?sslmode=disable"  # On macOS, username is your login username
ENVIRONMENT=dev
SECRET_KEY="$(openssl rand -base64 64)"  # Generate a secure key
PORT=8080
LOG_LEVEL=debug
HOST=127.0.0.1
```

The secret key is used to sign the JWT access tokens used by the service.

### PostgreSQL Database Setup (macOS)
```bash
# 1. Install and start PostgreSQL server
brew install postgresql@17
brew services start postgresql@17  # Use "start" to register the service to start at login

# 2. Connect to PostgreSQL server
psql postgres

# 3. Create the service database
CREATE DATABASE signalsd_admin;

# 4. Configure your connection
export DATABASE_URL="postgres://$(whoami):@localhost:5432/signalsd_admin?sslmode=disable"
```

### Database Management
The database schema is managed by [goose](https://github.com/pressly/goose):
```bash
# Drop all database objects
goose -dir app/sql/schema postgres $DATABASE_URL down-to 0

# Update the schema to the current version - run this after pulling code from the GitHub repo
goose -dir app/sql/schema postgres $DATABASE_URL up
```

### Build and Run
```bash
cd app
go build ./cmd/signalsd/
./signalsd -mode all

# Or run directly
go run cmd/signalsd/main.go -mode all
```

## API Documentation
To generate the OpenAPI docs:
```bash
swag init -g cmd/signalsd/main.go
```
The docs are hosted as part of the signalsd service: [API docs](http://localhost:8080/docs)

## Database Management
### Schema Changes
Database schema alterations are made by adding files to `app/sql/schema`:
```
001_foo.sql
002_bar.sql
...
```
Goose will run the changes in the order the files are sorted.

### SQL Queries
SQL queries are kept in `app/sql/queries`.

Run `sqlc generate` from the root of the project to regenerate the type safe Go code after adding or altering any queries.


### Getting Help
- Check the [API documentation](https://information-sharing-networks.github.io/signalsd/app/docs/index.html)
- Review logs: `docker compose logs -f`
- Open an [issue](https://github.com/information-sharing-networks/signalsd/issues) on GitHub


# Technical overview
## Auth
![auth.0.4.0](https://github.com/user-attachments/assets/643ec71a-f037-4a7e-9497-6023d9100e69)

## ISN config
![ISN config v0 5 0](https://github.com/user-attachments/assets/2be326f2-f4d0-485e-aeed-28076383cd8e)

## Signals
![Signals v0 5 0](https://github.com/user-attachments/assets/ffe9ad66-3026-40ad-94b7-83e7f5d7b4b8)

## Rate Limits
The service includes a shared rate limiter for all traffic regardless of source IP or user identity and protects all endpoints including auth, API, and admin routes.

This just provides basic protection against abuse - in a production environment you should configure your CDN/load balancer/reverse proxy with per-IP rate limiting.

## CI/CD overview

![ci_cd.0.2.0](https://github.com/user-attachments/assets/d5399e2f-0d0b-420b-9c17-0fbcea6f520c)


### Creating a Release
```bash
# 1. Test and prepare
git checkout main && git pull origin main
cd app && go test ./... && cd ..

# 2. Create and push version tag; build locally with version info
build.sh -t patch|minor|major

```
See GitHub Actions workflows in `.github/workflows/`


## Cloud Deployment
The service is deployed whenever a new version tag (e.g v1.0.0) is pushed. See the previous section on using the build script to trigger a new release.

The CD pipeline (cd.yml) builds a docker image based on the latest tagged release and deploys it to Google Cloud Run. Google handles HTTPS, firewall, load balancing and autoscaling. The service will scale to zero when not in use.

**Note: This is a pre-production version and should only be used with data that you don't mind being deleted or seen by other people.**

## Service Mode Configuration

You can run multiple instances of the signalsd service, each in a different mode.  This enables you to, for example, run a separate service for admin and signal processing workloads.
The service mode is specified using the `-mode` command line flag:

- **`all`**: Serves all endpoints 
- **`admin`**: Serves only admin API endpoints (excludes signal exchange)
- **`signals`**: Serves signal exchange endpoints (both read and write operations)
- **`signals-read`**: Serves only signal read operations 
- **`signals-write`**: Serves only signal write operations

```sh
PORT=8080 go run cmd/signalsd/main.go --mode admin
PORT=8081 go run cmd/signalsd/main.go --mode signals-read
PORT=8082 go run cmd/signalsd/main.go --mode signals-write
```

## Deployment Configurations
### Basic config
The simplest configuration is to run containers that serve all endpoints.  This is the configuration used by the github actions CD pipeline and - although fine for testing - it is not recommended for production use.

![deploy.0.2.0](https://github.com/user-attachments/assets/942384a7-ccd7-4abb-b2a7-a9e293e23a10)


### Separate Admin vs Signals containers config
It is a good idea to separate the admin api container from the signals exchange containers: although they still share a common database, it will ensure that admin requests are not blocked when there are a large number of concurrent signal processing requests.

See .github/workflow/cd-multi.yml for the github actions pipeline that can be used to deploy this configuration.

To use this configuration, set up Google Cloud Load Balancer with path-based routing to direct traffic to the signals and admin instances:

```yaml
- match:
    path:
      regex: "^/api/isn/.*/signal_types/.*/signals.*"
  route:
    cluster: signalsd-signals

- match:
    prefix: "/"
  route:
    cluster: signalsd-admin
```

### Advanced Config
A more advanced configuration is to separate read and write operations. This would be useful if using a read-only database replica for readers:

```yaml
# load balance config:
# Write operations
- match:
    path:
      regex: "^/api/isn/.*/signal_types/.*/signals$"
    method: "POST"
  route:
    cluster: signalsd-signals-write

# Read operations
- match:
    path:
      regex: "^/isn/.*/signal_types/.*/signals/.*"
    method: "GET"
  route:
    cluster: signalsd-signals-read

# Admin operations
- match:
    prefix: "/"
  route:
    cluster: signalsd-admin
```
![advanced config (v0 7 2)](https://github.com/user-attachments/assets/88b8fe9b-1329-45d9-b96c-fd4dde831026)


## Google Cloud Run Setup

The steps to set up this environment in Google Cloud are:

### 1. Create Google Cloud Resources
- Create a project called `signalsd`
- Create an artifact registry called `signalsd`

### 2. Create Service Accounts (IAM > Service Accounts)
- `cloud-run-deploy`
- `cloud-run-runtime`

### 3. Configure cloud-run-deploy Account
The `cloud-run-deploy` account will:
- Build an image each time there is a push on main
- Push the image to the artifact registry (the image is tagged with the commit id and 'latest')
- Create a container based on the latest image and deploy to Cloud Run (the container will run under the cloud-run-runtime account)

### 4. Set Service Account Permissions
- `cloud-run-deploy` needs the **Artifact Registry Writer** and **Cloud Run Admin** roles
- The `cloud-run-runtime` account does not need access to any of the Google APIs and therefore doesn't have any roles. You do however need to configure it to allow the cloud-run-deploy account to use it:

  **IAM > Service Accounts > cloud-run-runtime account > manage details > Principals with access > grant access**

  Add the cloud-run-deploy account email address - give it the **Service Account User** role.

### 5. Download Service Account Key
Download a JSON key for the cloud-run-deploy account:
**IAM > service accounts > cloud-run-deploy account > keys > add key > Create New**

### 6. Configure GitHub Secrets
Set up GitHub secrets in your fork of the repo:
**repo > settings > secrets and variables > actions > new repository secret**

You will need three:
- `GCP_CREDENTIALS` (upload the contents of the JSON key downloaded earlier)
- `DATABASE_URL` (URL of your postgres service - we are using Neon.tech, but you can use any provider you choose)
- `SECRET_KEY` (random secret key for your app - used by the signalsd server to sign JWT tokens)

### 7. Cost Considerations
Note that at the time of writing this service operates within the free-tiers offered by Google and Neon.Tech, but you should check the current rules to be sure.

That's it!
