// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: isn_retrievers.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createIsnRetriever = `-- name: CreateIsnRetriever :one
INSERT INTO isn_retrievers (
    id,
    created_at,
    updated_at,
    user_id,
    isn_id,
    title,
    detail,
    slug,
    retriever_origin,
    retriever_status,
    default_rate_limit
) VALUES (gen_random_uuid(), now(), now(), $1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, slug
`

type CreateIsnRetrieverParams struct {
	UserID           uuid.UUID `json:"user_id"`
	IsnID            uuid.UUID `json:"isn_id"`
	Title            string    `json:"title"`
	Detail           string    `json:"detail"`
	Slug             string    `json:"slug"`
	RetrieverOrigin  string    `json:"retriever_origin"`
	RetrieverStatus  string    `json:"retriever_status"`
	DefaultRateLimit int32     `json:"default_rate_limit"`
}

type CreateIsnRetrieverRow struct {
	ID   uuid.UUID `json:"id"`
	Slug string    `json:"slug"`
}

func (q *Queries) CreateIsnRetriever(ctx context.Context, arg CreateIsnRetrieverParams) (CreateIsnRetrieverRow, error) {
	row := q.db.QueryRowContext(ctx, createIsnRetriever,
		arg.UserID,
		arg.IsnID,
		arg.Title,
		arg.Detail,
		arg.Slug,
		arg.RetrieverOrigin,
		arg.RetrieverStatus,
		arg.DefaultRateLimit,
	)
	var i CreateIsnRetrieverRow
	err := row.Scan(&i.ID, &i.Slug)
	return i, err
}

const existsIsnRetrieverWithSlug = `-- name: ExistsIsnRetrieverWithSlug :one

SELECT EXISTS
  (SELECT 1
   FROM isn_retrievers
   WHERE slug = $1) AS EXISTS
`

func (q *Queries) ExistsIsnRetrieverWithSlug(ctx context.Context, slug string) (bool, error) {
	row := q.db.QueryRowContext(ctx, existsIsnRetrieverWithSlug, slug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getIsnRetrieverWithSlug = `-- name: GetIsnRetrieverWithSlug :one
SELECT
    i.slug AS isn_slug,
    i.is_in_use AS isn_is_in_use,
    i.storage_type AS isn_storage_type,
    ir.id, ir.created_at, ir.updated_at, ir.user_id, ir.isn_id, ir.title, ir.detail, ir.slug, ir.retriever_origin, ir.retriever_status, ir.default_rate_limit
FROM isn_retrievers ir
JOIN isn i ON i.id = ir.isn_id
WHERE ir.slug = $1
`

type GetIsnRetrieverWithSlugRow struct {
	IsnSlug          string    `json:"isn_slug"`
	IsnIsInUse       bool      `json:"isn_is_in_use"`
	IsnStorageType   string    `json:"isn_storage_type"`
	ID               uuid.UUID `json:"id"`
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
	UserID           uuid.UUID `json:"user_id"`
	IsnID            uuid.UUID `json:"isn_id"`
	Title            string    `json:"title"`
	Detail           string    `json:"detail"`
	Slug             string    `json:"slug"`
	RetrieverOrigin  string    `json:"retriever_origin"`
	RetrieverStatus  string    `json:"retriever_status"`
	DefaultRateLimit int32     `json:"default_rate_limit"`
}

func (q *Queries) GetIsnRetrieverWithSlug(ctx context.Context, slug string) (GetIsnRetrieverWithSlugRow, error) {
	row := q.db.QueryRowContext(ctx, getIsnRetrieverWithSlug, slug)
	var i GetIsnRetrieverWithSlugRow
	err := row.Scan(
		&i.IsnSlug,
		&i.IsnIsInUse,
		&i.IsnStorageType,
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.IsnID,
		&i.Title,
		&i.Detail,
		&i.Slug,
		&i.RetrieverOrigin,
		&i.RetrieverStatus,
		&i.DefaultRateLimit,
	)
	return i, err
}

const getIsnRetrievers = `-- name: GetIsnRetrievers :many
SELECT ir.id, ir.created_at, ir.updated_at, ir.user_id, ir.isn_id, ir.title, ir.detail, ir.slug, ir.retriever_origin, ir.retriever_status, ir.default_rate_limit 
FROM isn_retrievers ir
`

func (q *Queries) GetIsnRetrievers(ctx context.Context) ([]IsnRetriever, error) {
	rows, err := q.db.QueryContext(ctx, getIsnRetrievers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IsnRetriever
	for rows.Next() {
		var i IsnRetriever
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.IsnID,
			&i.Title,
			&i.Detail,
			&i.Slug,
			&i.RetrieverOrigin,
			&i.RetrieverStatus,
			&i.DefaultRateLimit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateIsnRetriever = `-- name: UpdateIsnRetriever :execrows
UPDATE isn_retrievers SET (
  updated_at, 
  detail,
  retriever_origin,
  default_rate_limit,
  retriever_status
) = (Now(), $2, $3, $4, $5)
WHERE id = $1
`

type UpdateIsnRetrieverParams struct {
	ID               uuid.UUID `json:"id"`
	Detail           string    `json:"detail"`
	RetrieverOrigin  string    `json:"retriever_origin"`
	DefaultRateLimit int32     `json:"default_rate_limit"`
	RetrieverStatus  string    `json:"retriever_status"`
}

func (q *Queries) UpdateIsnRetriever(ctx context.Context, arg UpdateIsnRetrieverParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateIsnRetriever,
		arg.ID,
		arg.Detail,
		arg.RetrieverOrigin,
		arg.DefaultRateLimit,
		arg.RetrieverStatus,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
